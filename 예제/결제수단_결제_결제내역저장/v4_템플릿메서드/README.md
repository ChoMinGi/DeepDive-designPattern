## 설계 관점
1. 쿠폰과 기프트 카드 등 결제 수단과 관련된 엔티티에 결제 내역으로 변환하는 인터페이스를 제공
2. 각 엔티티에 오버라이드한 메서드를 이용하여 객체 변환

## 설계 패턴; 템플릿 메서드 패턴
- 인터페이스를 구현한 클래스에 `PaymentArchive` 객체로 변환하는 과정을 구현

## 별로인 이유
처음에는 꽤나 괜찮은 아이디어라 생각하고 코드를 작성하고 있었다. 도메인 특성으로 인해서 크리티컬한 문제에 마주하는데..
- 쿠폰, 포인트, 네이버 페이등(서드파티)은 무리없이 적용이 가능하다! 트랜잭션이 단건 발생한다.(서드 파티의 경우에는 주문번호 혹은 제공자가 제공해주는 uuid)
- 기프트 카드의 경우에는 giftCardTrasaction 의 속성을 가져와야한다. 즉 인터페이스 구현을 GiftCard 내에서 하는 경우에는 GiftTrasaction 의 정보를 가져오기 때문에
  1. 매개변수를 통해서 PaymentArchive 의 변수를 지정해주거나
  2. 제네릭 타입으로 데이터를 가져오거나
  3. giftCardTrasaction에 인터페이스 구현체를 만들어주어야한다.

1번으로 하자니 호출 시 모든 매개변수를 명시해야 하므로, 메서드 호출 코드가 더 길고 복잡해진다. 7개 정도. 
2번으로 하자니 차라리 전략 패턴을 쓸것 같다. 혹은 팩토리메서드 패턴. 템플릿 메서드의 장점이 제대로 부각되지 않을것 같다.
3번으로 하자니 주체는 GiftCard 인데 다른 엔티티는 Coupon같은 주체에 가있으면서 GiftCard에만 예외를 두는게 일관적이지 않다고 생각했다.

## 그럼에도 사용해본 이유 V4.1

## 장점
 1. 다른 결제 수단과 마찬가지로 각 트랜잭션 엔티티가 자신의 변환 로직을 담당헤서 일관된 구조를 유지할 수 있게 해준다.
 2. 변환 로직이 GiftCardTransaction,Coupon 내에 존재함으로써, 트랜잭션 관련 데이터가 필요한 변환 로직의 책임이 분명해진다.
 3. 무엇보다 작성하는 코드의 양이 적어졌다.

## 단점
 1. 앞서 말했듯이 주체인 GiftCard 가 아닌 Transaction 에 주체가 있기에 걱정은 존재한다. 그만큼의 결합도가 상승했다.


하지만 형변환도 존재하지 않고 의존성 분리도 아주 용이해서 고민중에 있다.

## 나름의 합의점 V4.2
서비스단 내에 서비스단의 의존성을 가지는것을 방지하고, 트랜잭션 발생시에 들어오는 DTO를 최대한 활용하기 위해서 PaymentArchivable 이라는 인터페이스 내의 메서드에 회원정보(전화번호), 금액, 트랜잭션 타입을 받아와서 구현을 GiftCardTransaction 에서 GiftCard 내부로 옮겼다.